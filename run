#!/usr/bin/env bash
set -euo pipefail

# run: single entrypoint for lint, test, and release

ROOT_DIR="$(cd "$(dirname "$0")" && pwd)"
SRC_DIR="$ROOT_DIR/src"
VERSION_FILE="$ROOT_DIR/src/dazpycheck/__init__.py"

red()   { printf "\033[31m%s\033[0m\n" "$*"; }
green() { printf "\033[32m%s\033[0m\n" "$*"; }
yellow(){ printf "\033[33m%s\033[0m\n" "$*"; }
blue()  { printf "\033[34m%s\033[0m\n" "$*"; }

usage() {
  cat <<EOF
Usage: ./run <command>

Commands:
  check       Run all checks on the codebase
  test        Run all tests
  release     Bump version, build, and upload to PyPI
  help        Show this help

Examples:
  ./run check
  ./run test
  ./run release
EOF
}

ensure_tools() {
  python - <<'PY'
import importlib, sys
missing = []
for pkg in ("ruff", "pytest", "build", "twine", "keyring", "coverage"):
    try:
        importlib.import_module(pkg)
    except Exception:
        missing.append(pkg)
if missing:
    print("Missing packages: " + ", ".join(missing))
    sys.exit(1)
PY
}

cmd_check() {
  blue "Running dazpycheck..."
  PYTHONPATH="$SRC_DIR${PYTHONPATH+:$PYTHONPATH}" dazpycheck --full .
  green "Check passed"
}

cmd_test() {
  blue "Running pytest…"
  PYTHONPATH="$SRC_DIR${PYTHONPATH+:$PYTHONPATH}" pytest -q
}

cmd_build() {
  blue "Cleaning and building…"
  rm -rf dist build *.egg-info
  PIP_CONFIG_FILE=/dev/null python -m build
  green "Build complete"
}

cmd_release() {
    blue "Bumping minor version…"
    python - <<PY
from pathlib import Path
import re
p = Path("$VERSION_FILE")
text = p.read_text(encoding="utf-8")
m = re.search(r"^__version__ = ['\"](\d+)\.(\d+)\.(\d+)['\"]", text, re.M)
if not m:
    raise SystemExit("ERROR: version not found in __init__.py file")
maj, minor, patch = map(int, m.groups())
minor, patch = minor + 1, 0
new = f"{maj}.{minor}.{patch}"
text = re.sub(r"^(__version__ = ['\"])(\d+)\.(\d+)\.(\d+)(['\"])", rf"\g<1>{new}\g<5>", text, flags=re.M)
p.write_text(text, encoding="utf-8")
print(new)
PY

    NEW_VER=$(python - <<PY
from pathlib import Path
import re
p = Path("$VERSION_FILE")
text = p.read_text(encoding="utf-8")
m = re.search(r"^__version__ = ['\"]([^'\"]*)['\"]", text, re.M)
if m:
    print(m.group(1), end="")
PY
)
    green "Version bumped to v$NEW_VER"

    blue "Installing build + twine if missing…"
    python -m pip install -U build twine >/dev/null 2>&1 || true

    cmd_build

    blue "Fetching PyPI token from keyring…"
    RAW_TOKEN=$(python - <<'PY'
import keyring
val = keyring.get_password("pypi", "api_token") or ""
print(val, end="")
PY
)
    if [ -z "$RAW_TOKEN" ]; then
        red "ERROR: No API token in keyring for service 'pypi' (user: api_token)"
        echo "Add it with:  python -m keyring set pypi api_token" >&2
        exit 1
    fi

    export TWINE_USERNAME="__token__"
    export TWINE_PASSWORD="$RAW_TOKEN"
    blue "Uploading distributions via twine…"
    twine upload dist/*
    green "Release uploaded"
}

main() {
  local cmd="${1:-help}"
  case "$cmd" in
    check)   cmd_check ;;
    test)    cmd_test ;;
    build)   cmd_build ;;
    release) cmd_release ;;
    help|*)  usage ;;
  esac
}

main "$@"
